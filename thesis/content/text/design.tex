% -*- root: ../../main.tex -*- %
\subsection{Components} % (fold)
\label{sub:components}
  As noted in \ref{par:micro_services_architecture}, one of the downsides of \ac{MSA} is that it is crucial to determine suitable service boundaries. Some sources advise to first build a monolithic application and then analyze the result to single out services that can be extracted. In case of \acp{WfMS}, the identification of system components by the \ac{WFMC} for their reference model can be interpreted as such an analysis. Based on those components further micro-services for the prototype are then identified.

  As presented in \ref{sub:system_components}, the \ac{WFMC} identified the following components:
    \begin{itemize}[nosep]
      \item Software Components
        \begin{itemize}[nosep]
          \item Definition Tool
          \item Organization Modeling Tool
          \item User Interface
          \item Workflow Engine(s)
          \item Worklists Handler
        \end{itemize}
      \item Data Components
        \begin{itemize}[nosep]
          \item Organization Data
          \item Process Definitions Data
          \item Workflow Control Data
          \item Workflow Relevant Data
          \item Worklists Data
        \end{itemize}
    \end{itemize}

    - ui adapted to suit the API gateway pattern
    - user interface split per purpose (dev/user)

  Besides the major components, independent functionalities which are frequently used may be singled out to own services. To demonstrate this exemplarily, a service which deals with the validation of input and output data is extracted for this prototype.

  In the following, the resulting set of services is presented.

    \subsubsection{Workflow Definition Service} % (fold)
      \label{subs:workflow_definition_service}

      The workflow definition service encompasses the functions envisioned by the \ac{WFMC} as Process Definition Tools, \ie it is concerned with the analysis, modeling, description and documentation of business processes in form of workflow models and their process definitions. It further manages the assignment of activities to roles.

      With regards to that functional scope, this is also the component that should handle the transformation of workflows into their distributable format, \eg a self-contained description file or Docker images. In case of the latter, the workflow definition service would require access to a Docker daemon in order to perform the export. Once a workflow is transformed, the service should publish it.

      This components needs to incorporate the concepts required for its task. That is, workflow, activity , process definition, and control flow. The roles assigned to activities have only to be dealt with as unique identifiers, relying on the assumption that components which have to use them may resolve them themselves.

      According to the concept of \ac{MSA}, the workflow definition service component does not bring its own user interface, but rather exposes only an \ac{API}. This allows workflow definitions to be created and altered by arbitrary other services, \eg some converting service which translates other process definition formats, some feedback mechanism that alters workflows based on their execution performance, or different gateways which provide suitable user interfaces for various user devices.
      % subsubsection workflow_definition_service (end)

    \subsubsection{Organization Management Service} % (fold)
      \label{subs:organization_management_service}
      The organization management service is part of the ``administration and monitoring tools''.
      As its name suggests, its functionality is aimed at the management of actors within an organization and their mutual relationships. Based this information, it may be queried for users or roles, or authenticate users for the use of the \ac{WfMS}. Just like the workflow definition service, this service only exposes an \ac{API}.
      % subsubsection organization_management_service (end)

    \subsubsection{Worklist Service} % (fold)
      \label{subs:worklist_service}
      The sole responsibility of this service is the management of users' worklists. It should create and delete worklist items on request and publish the data users submitted to it. If an user is deleted, it should reschedule the worklist item to a new provided user.
      % subsubsection worklist_service (end)

    \subsubsection{Workflow Engine Service} % (fold)
      \label{subs:workflow_engine_service}

      In wide parts, the workflow engine service is congruent to the ``workflow engine'' as identified by the \ac{WFMC} in terms of functionality. It is
      As its responsibilities encompass the provision of the runtime environment, the workflow engine service should instanciate a provisioner on a node when it is added to the swarm. It also should ensure, that

      - choose participants
      - add to execution networks

      The chosen option from the solutions presented in \ref{sec:docker_for_wf_execution} has an impact on the range of functionalities that this service has.

      The extent to which the workflow engine service controls the instanciation of workflow components depends on .
      % subsubsection workflow_engine_service (end)

    \subsubsection{Developer Gateway} % (fold)
      \label{subs:developer_gateway}



        - provides access to
          - infrastructure
          - definition
          - organization
      % subsubsection developer_gateway (end)

    \subsubsection{User Gateway} % (fold)
      \label{subs:user_gateway}
        - provides access to
          - worklists
          - forms
      % subsubsection user_gateway (end)

    \subsubsection{Organization Data} % (fold)
    \label{subs:organization_data}

    % subsubsection organization_data (end)
    \subsubsection{Process Definitions Data} % (fold)
    \label{subs:process_definitions_data}

    % subsubsection process_definitions_data (end)
    \subsubsection{Workflow Control Data} % (fold)
    \label{subs:workflow_control_data}

    % subsubsection workflow_control_data (end)
    \subsubsection{Workflow Relevant Data} % (fold)
    \label{subs:workflow_relevant_data}

    % subsubsection workflow_relevant_data (end)
    \subsubsection{Worklists Data} % (fold)
    \label{subs:worklists}

    % subsubsection worklists (end)

  \subsubsection{Validation Service} % (fold)
    \label{subs:valitation_service}
    One micro-service that might be extracted from the above services concerns the validation of data. Given a dataset and a set of rules on how to validate this dataset, the service is able to perform its task autonomously. As validation is a frequently recurring action in the execution of workflows -- before and after each activity and workflow -- it could thus be beneficial to be able to scale the execution of this task independently.
    % subsubsection valitation_service (end)

  \subsubsection{Support Services} % (fold)
  \label{ssub:support_components}
    There are three services which are required for the infrastructure in order to achieve the specified objectives. First, some \ac{MOM}, as it enables the communication between all components. Second, a service that allows the configuration of the execution environment. And third, a component that takes care of provisioning all machines with the images they require.

    \subsubsection{Message Oriented Middleware} % (fold)
      \label{subs:message_oriented_middleware}
      - must be reachable by all other services
      % subsubsection message_oriented_middleware (end)

    \subsubsection{Infrastructure Management Service} % (fold)
      \label{subs:environment_management_service}

        - see machines in the swarm
        - see their (labelled) properties
        - see (running) containers and available images
      % subsubsection environment_management_service (end)

    \subsubsection{Registry} % (fold)
    \label{subs:registry}
      All solutions presented in Section~\ref{sec:docker_for_wf_execution} feature custom Docker images, be it workers or contanierized activities or workflows. These images presumably contain information on business processes and other information whose disclosure should be avoided.  In order to store and distribute these images, a private registry is thus required.

      A possible alternative for less sensitive images could be the utilization of a private remote repository on the Docker Hub.
    % subsubsection registry (end)

    \subsubsection{Provisioning Service} % (fold)
      \label{subs:provisioning_service}
        The objectives include the reduction of administrative work. In order to prevent the user from having to distribute the Docker images required for the execution of workflows manually, a service should perform this task. This service should provision each machine with said images whenever such an image is created or updated. If a workflow or an activity is deleted, the service should remove its respective image from all machines.

        The service could either run as an instance on each machine, performing the required Docker operations locally, or run on the Docker Swarm master machine as one instance and perform the operations remotely on all machines.
      % subsubsection provisioning_service (end)
  % subsubsection support_components (end)

  \begin{figure}[htbp]
    \centering
    \includegraphics[width=0.95\textwidth]{content/images/Architecture-crop.pdf}
    \caption*{\scriptsize Note: the depicted distribution of containers to nodes is just exemplarily. Most of them could run on any node in the swarm. The only mandatory assignments are the swarm agents, of which each node needs one, and the provisioners, of which each node that is intended to execute workflows on needs one. \\ Also, the databases and their respective data volumes were omitted for the sake of clarity.}
    \caption{Deployment Diagram of the Architecture}
    \label{fig:label}
  \end{figure}
% subsection components (end)

\subsection{Workflow and Activity Images} % (fold)
\label{sub:workflow_activity_images}
  To reap the benefits of the layer mechanism, the structure of the images should be chosen with care. Layers should be created in a way that enables reusability among the different use cases and they should be ordered by the frequency that they are changed with.

  The proposed structure of workflow and activity images, which is depicted in Figure~\ref{fig:layers_for_element_wrapping_containers} and reflected in the respective Dockerfiles \ref{}, \ref{}, , is thus as follows.

  The proposed structure consists on three images, which should build on each other consecutively, as they are meant to be increasingly specialized. The first image should provide the runtime environment. This image could be provided by a third-party vendor that specializes in building such images, \ie an \ac{OS} community or framework developers. Based on this image, a generic activity image \texttt{ac\_base} (and, for $*_{SEPC}^{*}$, a generic workflow image \texttt{wf\_base}) should be created. This image can be extended with element-specific information for each element of a workflow, when that workflow is exported for deployment, to yield the uppermost images \texttt{ac\_\$activity\_id} (and \texttt{wf\_\$workflow\_id}). An instance of this last image would then be a container with a suitable name of the form \texttt{aci\_\$activity\_instance\_id} (and respectively \texttt{wfi\_\$workflow\\\_instance\_id}).

  \begin{figure}[htbp]
    \centering
    \includegraphics[width=0.95\textwidth]{content/images/layer_concept-crop.pdf}
    \caption{Layer Structure for Activity/Workflow Images}
    \label{fig:layers_for_element_wrapping_containers}
  \end{figure}

  Regarded in a more detailed fashion, the images' structure should look as follows.
  The foundation should be formed by \emph{runtime environment layers}, as they are expected to change rather seldom and are required by all derived images. Usually, these layers contain an \ac{OS}, common libraries and utility programs.

  The layers that form the \emph{$^*$\_base} images can be separated in two groups, \emph{common layers} and \emph{element-type-specific layers}. The \emph{element type} refers to either activity or workflow.
  The common layers should be created on top of these runtime environment layers. They are intended to contain the effects of invoked commands, added directory structures and files which are required by both activity images and workflow images. Even though no explicit name is given to these layers, they will be stored by Docker in its cache and used during the build process.

  In the next step, element-type-specific layers should be added. These layers are meant to contain data that is required for the execution of an activity \emph{or} a workflow, for example scripts which perform validation tasks (if they are not provided by a service) or general-purpose data transformation.

  The element-specific layer, which is added in the course of the export of an element (activity or workflow), contains files that are particular to single workflows or activities. In case of workflow images, for example, this layer would contain the process definition. In an activity image, it would contain the activity configuration and the schemata for data validation.

  By instantiating the resulting image a container is created at runtime, which owns the uppermost, writable layer. This is where the activity or workflow may store data that it needs during execution.

  At the time of writing, Docker registries do not yet reuse layers across repository borders during uploads, even though it is a proposed feature \cite{Mcgowan2015Proposal}. In order to benefit from the layering in the previously described way, it is thus necessary to let all activity images reside in the same repository by tagging them in the format

  \centerline{\texttt{\$repository\_url/activity}}

  and using the respective activity's \ac{ID} as a version tag to differentiate between them. They can then be referred to as

  \centerline{\texttt{\$repository\_url/activity:ac\_\$activity\_id}}

  Analogously, this is done with workflow images. Since it implies losing the internal image versioning mechanism, this solution should only be used as a workaround until cross-repository sharing of layers is possible.
% subsection workflow_activity_images (end)

\subsection{Communication} % (fold)
  \label{sub:application_level_communication}
  While the previous considerations were targeted at finding a model for the low-level communication, a way how the services communicate with each other

  - likeliness of scaling
  - REST between non-scaling services
  - MOM for broadcasts / asynchronous jobs

% subsection application_level_communication (end)

  % \begin{sequencediagram}
  % \newinst{u}{Developer Gateway}
  % \newinst[1]{d}{Definition Service}
  % \newinst[1]{m}{MOM}
  % \newinst[1]{p}{Provisioner}

  % \mess{u}{subscribe}{m}
  % \mess{d}{subscribe}{m}
  % \mess{p}{subscribe}{m}

  % \mess{u}{wfms.wf.create}{m}
  % \mess{m}{wfms.wf.create}{d}
  % \mess{d}{wfms.wf.created}{m}
  % \mess{m}{wfms.wf.created}{u}
  % \mess{u}{wfms.pd.update}{m}
  % \mess{m}{wfms.pd.update}{d}
  % \mess{d}{wfms.pd.updated}{m}
  % \mess{m}{wfms.pd.updated}{u}
  % \mess{u}{wfms.wf.export}{m}
  % \mess{m}{wfms.wf.export}{d}
  % \mess{d}{wfms.wf.exported}{m}
  % \mess{m}{wfms.wf.exported}{p}
  % \mess{m}{wfms.wf.exported}{u}

  % \end{sequencediagram}

% subsection inter_component_communication (end)
